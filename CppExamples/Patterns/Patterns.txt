
=======================================
pImpl Idiom (pointer-to-implementation)
=======================================

- Separates the implementation (.cpp) from the definition (.h)
- A class that implements the pImpl idiom has just one private variable - a pointer to the implementation class.
- The advantage of using the pImpl idiom is that we can change the private 
  part of the implementation class and minimize the need for recompilation.
- When there is a class whose header is included in many places, first see if forward declarations would help you.
  If nothing uses certain classes, try to use the forward declaration (??? why to include the header at first place ???)

A class that is a good candidate for the pImpl idiom:
- Already non-copyable
- -or- not being copied in any existing code
- -or- you write a deep copy so the existing code still works
- Most useful when the class has a stable public interface and volatile private interface.
  Otherwise you will have to make changes in two places:
  the actual class (Account.h) and implementation class (AccountImpl.h)

pImpl structure with unique_ptr:
- Everybody #includes Account.h
- Account.h defines the public interface. It has a forward declaration to AccountImpl.
- Account.cpp delegates calls to AccountImpl
- Account.cpp #includes both Account.h and AccountImpl.h
- AccountImpl.h defines an interface for the implementation of Account
- AccountImpl.cpp provides the actual implementation of Account

//
// Account.h
//

// forward declaration
class AccountImpl;

class Account
{
public:
    Account();

    // Destr must be always defined even if it's empty.
    ~Account();

    // Move ctor and move assignment operator are optional. Do not define them if you
    // want your class to be non-moveable.
    Account(Account&& other);
    Account operator=(Account&& other);

    int MyMethod(int a);
private:
    std::unique_ptr<AccountImpl> pImpl;
}

//
// Account.cpp
//
#include "Account.h"
#include "AccountImpl.h"

// Each Account's function delegates its implementation to pImpl.
int Account::MyMethod(int a)
{
    return pImpl->MyMethod(a);
}

// Define the destr, move ctor, and move assignment operator manually. The ones
// generated by the compiler are generated when the class is still incomplete.
// This is a consequence of the forward declaration of AccountImpl. The compiler
// has only the declaration, not the entire class definition.

// The structure of the destr, move ctor, and move assignment operator are always 
// the same for all classes that use the pImpl idiom.

Account::~Account() { }

Account::Account(Account&& other) : pImpl(std::move(other.pImpl)) { }

Account& Account::operator=(Account&& other)
{
    pImpl = std::move(other.pImpl);
    return *this;
}
