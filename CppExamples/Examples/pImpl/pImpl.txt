
=======================================
pImpl Idiom (pointer-to-implementation)
=======================================

- Separates the implementation (.cpp) from the definition (.h)
- Keeps implementation details out of the public header files.
- A class that implements the pImpl idiom has just one private variable - a pointer to the implementation class.

Advantages:
- Faster compiles: we can change the private part of the implementation class and minimize the need for recompilation.
- Reduced coupling: we can move class dependencies to the .cpp file.
- Greater binary compatibility: The size of a pimpled object never changes (it's a pointer). Any changes to the private
  member variables only affect the size of the implementation class that is hidden inside the .cpp file.
- Lazy allocation: we can construct the implementation class on demand.

A class that is a good candidate for the pImpl idiom:
- Already non-copyable
- -or- not being copied in any existing code
- -or- you write a deep copy so the existing code still works
- Most useful when the class has a stable public interface and volatile private interface.
  Otherwise you will have to make changes in two places:
  the actual class (Account.h) and implementation class (AccountImpl.h)

Downsides:
- You can't hide private virtual methods in the implementation class. The private virtual methods 
  must appear in the public class.
- You may need to add a pointer in the impl class back to the public class so that the impl class
  can call public methods. You could also pass the public class into the impl class methods
  that need it.
- There is a performance hit for the extra level of pointer indirection required to access member 
  variables as well as the cost of additional calls to new and delete. There is "Fast Pimpl" that 
  improves the memory allocation performance. It overloads the new and delete operators for the 
  implementation class.
- The compiler won't catch changes to member variables within const methods. This is because member
  variables live in a separate object.

pImpl structure with unique_ptr:
- Everybody #includes Account.h
- Account.h defines the public interface. It has a forward declaration to AccountImpl as a private member.
- Account.cpp contains the interface and the implementation of AccountImpl.
- Account.cpp delegates calls to AccountImpl

//
// Account.h
//

// forward declaration
class AccountImpl;

class Account
{
public:
    Account();

    // Destr must be always defined even if it's empty.
    ~Account();

    // Move ctor and move assignment operator are optional. Do not define them if you
    // want your class to be non-moveable.
    Account(Account&& other);
    Account operator=(Account&& other);

    int MyMethod(int a);

private:
    // pImpl is a pointer to a forward declared type.
    // The user cannot see the details of the object being pointed to.
    std::unique_ptr<AccountImpl> pImpl;
}

//
// Account.cpp
//
#include "Account.h"
#include "AccountImpl.h"

// Each Account's function delegates its implementation to pImpl.
int Account::MyMethod(int a)
{
    return pImpl->MyMethod(a);
}

// Define the destr, move ctor, and move assignment operator manually. The ones
// generated by the compiler are generated when the class is still incomplete.
// This is a consequence of the forward declaration of AccountImpl. The compiler
// has only the declaration, not the entire class definition.

// The structure of the destr, move ctor, and move assignment operator are always 
// the same for all classes that use the pImpl idiom.

Account::~Account() { }

Account::Account(Account&& other) : pImpl(std::move(other.pImpl)) { }

Account& Account::operator=(Account&& other)
{
    pImpl = std::move(other.pImpl);
    return *this;
}
