
=======================================
pImpl Idiom (pointer-to-implementation)
=======================================

- Separates the implementation (.cpp) from the definition (.h)
- Keeps implementation details out of the public header files.
- A class that implements the pImpl idiom has just one private variable - a pointer to the implementation class.
- The advantage of using the pImpl idiom is that we can change the private 
  part of the implementation class and minimize the need for recompilation.

A class that is a good candidate for the pImpl idiom:
- Already non-copyable
- -or- not being copied in any existing code
- -or- you write a deep copy so the existing code still works
- Most useful when the class has a stable public interface and volatile private interface.
  Otherwise you will have to make changes in two places:
  the actual class (Account.h) and implementation class (AccountImpl.h)

Downsides:
- You can't hide private virtual methods in the implementation class. The private virtual methods 
  must appear in the public class.
- You may need to add a pointer in the impl class back to the public class so that the impl class
  can call public methods. You could also pass the public class into the impl class methods
  that need it.

pImpl structure with unique_ptr:
- Everybody #includes Account.h
- Account.h defines the public interface. It has a forward declaration to AccountImpl as a private member.
- Account.cpp contains the interface and the implementation of AccountImpl.
- Account.cpp delegates calls to AccountImpl

//
// Account.h
//

// forward declaration
class AccountImpl;

class Account
{
public:
    Account();

    // Destr must be always defined even if it's empty.
    ~Account();

    // Move ctor and move assignment operator are optional. Do not define them if you
    // want your class to be non-moveable.
    Account(Account&& other);
    Account operator=(Account&& other);

    int MyMethod(int a);

private:
    // pImpl is a pointer to a forward declared type.
    // The user cannot see the details of the object being pointed to.
    std::unique_ptr<AccountImpl> pImpl;
}

//
// Account.cpp
//
#include "Account.h"
#include "AccountImpl.h"

// Each Account's function delegates its implementation to pImpl.
int Account::MyMethod(int a)
{
    return pImpl->MyMethod(a);
}

// Define the destr, move ctor, and move assignment operator manually. The ones
// generated by the compiler are generated when the class is still incomplete.
// This is a consequence of the forward declaration of AccountImpl. The compiler
// has only the declaration, not the entire class definition.

// The structure of the destr, move ctor, and move assignment operator are always 
// the same for all classes that use the pImpl idiom.

Account::~Account() { }

Account::Account(Account&& other) : pImpl(std::move(other.pImpl)) { }

Account& Account::operator=(Account&& other)
{
    pImpl = std::move(other.pImpl);
    return *this;
}
